<!-- NOTE: does not work on Safari -->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebRTC Video File Streamer</title>
  <!-- Tailwind CSS for styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: 'Inter', sans-serif;
    }

    .video-container {
      background-color: #000;
      border-radius: 0.5rem;
      overflow: hidden;
      position: relative;
    }

    .video-placeholder {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #9ca3af;
    }
  </style>
</head>

<body class="bg-gray-900 text-gray-100 flex items-center justify-center min-h-screen">

  <div class="w-full max-w-5xl mx-auto p-4 md:p-6">
    <header class="text-center mb-6">
      <h1 class="text-3xl md:text-4xl font-bold text-white">WebRTC Video File Streamer</h1>
      <p class="text-gray-400 mt-2">Stream a video file directly to another browser peer-to-peer.</p>
    </header>

    <!-- Connection Status & Controls -->
    <div class="bg-gray-800 p-4 rounded-lg mb-6 shadow-lg">
      <div class="flex flex-col sm:flex-row items-center justify-between gap-4">
        <div class="text-center sm:text-left">
          <span class="font-semibold">Your ID:</span>
          <span id="my-id" class="bg-gray-700 text-green-400 px-3 py-1 rounded-md font-mono">Connecting...</span>
        </div>
        <div id="status" class="text-yellow-400 font-semibold">
          STATUS: Disconnected
        </div>
        <div class="flex items-center gap-2">
          <input type="text" id="target-id-input" placeholder="Enter Peer ID"
            class="bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500 w-full sm:w-auto">
          <button id="connect-btn"
            class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition duration-300 disabled:bg-gray-500 disabled:cursor-not-allowed">
            Connect
          </button>
        </div>
      </div>
      <div class="mt-4">
        <h3 class="font-semibold mb-2">Connected Users:</h3>
        <div id="user-list" class="flex flex-wrap gap-2">
          <span class="text-gray-500">No other users online.</span>
        </div>
      </div>
    </div>

    <!-- Video Players -->
    <main class="grid md:grid-cols-2 gap-6">
      <!-- Sender -->
      <div class="bg-gray-800 p-4 rounded-lg shadow-lg">
        <h2 class="text-xl font-bold mb-3 text-center">Sender</h2>
        <div class="video-container aspect-video">
          <video id="localVideo" playsinline class="w-full h-full object-contain"></video>
          <div id="local-placeholder" class="video-placeholder">No file selected</div>
        </div>
        <div class="mt-4 text-center">
          <label for="fileInput"
            class="cursor-pointer bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md transition duration-300 inline-block">
            Select Video File
          </label>
          <input type="file" id="fileInput" accept="video/*" class="hidden">
        </div>
      </div>

      <!-- Receiver -->
      <div class="bg-gray-800 p-4 rounded-lg shadow-lg">
        <h2 class="text-xl font-bold mb-3 text-center">Receiver</h2>
        <div class="video-container aspect-video">
          <video id="remoteVideo" playsinline autoplay class="w-full h-full object-contain"></video>
          <div id="remote-placeholder" class="video-placeholder">Waiting for stream...</div>
        </div>
      </div>
    </main>
  </div>

  <script>
    const myIdElement = document.getElementById('my-id');
    const targetIdInput = document.getElementById('target-id-input');
    const connectBtn = document.getElementById('connect-btn');
    const statusElement = document.getElementById('status');
    const userListElement = document.getElementById('user-list');
    const fileInput = document.getElementById('fileInput');
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const localPlaceholder = document.getElementById('local-placeholder');
    const remotePlaceholder = document.getElementById('remote-placeholder');

    // Use a publicly available STUN server
    const configuration = {
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    };

    let myId = '';
    let websocket;
    let peerConnection;
    let localStream;

    // --- WebSocket Signaling ---
    function connectWebSocket() {
      // Generate a simple unique ID for this client
      const clientId = `user-${Math.random().toString(36).substr(2, 9)}`;
      myId = clientId;
      myIdElement.textContent = myId;

      const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      // Replace with your server's address if not running locally
      const wsUrl = `${wsProtocol}//${window.location.hostname}:8000/ws/${clientId}`;

      websocket = new WebSocket(wsUrl);

      websocket.onopen = () => {
        console.log('WebSocket connection established.');
        updateStatus('Connected to server', 'text-green-400');
      };

      websocket.onmessage = (event) => {
        const message = JSON.parse(event.data);
        console.log('Received message:', message);

        switch (message.type) {
          case 'users':
            updateUserList(message.data);
            break;
          case 'offer':
            handleOffer(message.data, message.from);
            break;
          case 'answer':
            handleAnswer(message.data);
            break;
          case 'candidate':
            handleCandidate(message.data);
            break;
        }
      };

      websocket.onclose = () => {
        console.log('WebSocket connection closed.');
        updateStatus('Disconnected from server', 'text-red-400');
        // Optional: implement reconnection logic here
      };

      websocket.onerror = (error) => {
        console.error('WebSocket error:', error);
        updateStatus('Connection Error', 'text-red-400');
      };
    }

    function sendMessage(message) {
      if (websocket && websocket.readyState === WebSocket.OPEN) {
        websocket.send(JSON.stringify(message));
      } else {
        console.error('WebSocket is not connected.');
      }
    }

    // --- UI Updates ---
    function updateStatus(text, colorClass) {
      statusElement.textContent = `STATUS: ${text}`;
      statusElement.className = `font-semibold ${colorClass}`;
    }

    function updateUserList(users) {
      // Filter out the current user's ID
      const otherUsers = users.filter(id => id !== myId);
      userListElement.innerHTML = ''; // Clear current list

      if (otherUsers.length === 0) {
        userListElement.innerHTML = '<span class="text-gray-500">No other users online.</span>';
        return;
      }

      otherUsers.forEach(user => {
        const userElement = document.createElement('span');
        userElement.textContent = user;
        userElement.className = 'bg-gray-700 text-blue-300 px-3 py-1 rounded-md font-mono cursor-pointer hover:bg-gray-600';
        userElement.onclick = () => {
          targetIdInput.value = user;
        };
        userListElement.appendChild(userElement);
      });
    }

    // --- WebRTC Logic ---
    function createPeerConnection() {
      peerConnection = new RTCPeerConnection(configuration);

      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          sendMessage({
            target: targetIdInput.value,
            type: 'candidate',
            data: event.candidate,
          });
        }
      };

      peerConnection.ontrack = (event) => {
        console.log('Track received');
        remotePlaceholder.style.display = 'none';
        remoteVideo.srcObject = event.streams[0];
      };

      peerConnection.onconnectionstatechange = () => {
        console.log(`Connection state: ${peerConnection.connectionState}`);
        if (peerConnection.connectionState === 'connected') {
          updateStatus(`Streaming to ${targetIdInput.value}`, 'text-green-400');
        } else if (peerConnection.connectionState === 'failed' || peerConnection.connectionState === 'disconnected') {
          updateStatus('Connection lost', 'text-red-400');
          resetConnection();
        }
      }
    }

    async function startConnection() {
      const targetId = targetIdInput.value;
      if (!targetId) {
        alert('Please enter a Peer ID to connect to.');
        return;
      }
      if (!localStream) {
        alert('Please select a video file first.');
        return;
      }

      console.log(`Starting connection to ${targetId}`);
      updateStatus(`Connecting to ${targetId}...`, 'text-yellow-400');

      createPeerConnection();

      // Add local stream tracks to the connection
      localStream.getTracks().forEach(track => {
        peerConnection.addTrack(track, localStream);
      });

      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);

      sendMessage({
        target: targetId,
        type: 'offer',
        data: offer,
      });
    }

    async function handleOffer(offer, fromId) {
      targetIdInput.value = fromId; // Automatically set the target
      createPeerConnection();

      await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);

      sendMessage({
        target: fromId,
        type: 'answer',
        data: answer,
      });
      updateStatus(`Receiving call from ${fromId}`, 'text-yellow-400');
    }

    async function handleAnswer(answer) {
      if (peerConnection) {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
      }
    }

    async function handleCandidate(candidate) {
      if (peerConnection) {
        try {
          await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
        } catch (e) {
          console.error('Error adding ICE candidate', e);
        }
      }
    }

    function resetConnection() {
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }
      remoteVideo.srcObject = null;
      remotePlaceholder.style.display = 'block';
      updateStatus('Disconnected', 'text-yellow-400');
    }

    // --- Event Listeners ---
    fileInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) {
        const fileURL = URL.createObjectURL(file);
        localVideo.src = fileURL;
        localVideo.muted = true; // Mute local preview to avoid feedback
        localVideo.play();
        localPlaceholder.style.display = 'none';

        // Capture stream from the video element
        localStream = localVideo.captureStream();
        console.log('Video file loaded and stream captured.');
      }
    });

    connectBtn.addEventListener('click', startConnection);

    // Initialize WebSocket connection on page load
    window.addEventListener('load', connectWebSocket);
  </script>
</body>

</html>
